<!DOCTYPE html>
<html>
    <head>
        <title>LoopHole</title>
        <link rel="icon" href="http://loophole.studio/images/favicon.ico" type="x-icon" />
        <link rel="stylesheet" type="text/css" href="datalink.css">
        <script src="https://kit.fontawesome.com/b99e675b6e.js"></script>
        <script src="navbar.js"></script>
        <script src="data_table.js"></script>
        <script src="http://loophole.studio/network/totop.js"></script>
        <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body>
    <button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>
        <div class="hero-image">
        
          <div class="hero-text">
            <h1>Osi Model</h1>
            <p>By Wilson</p>
          </div>
        </div>
        <div class="menu" id="navbar">
            <ul>
                <li><a href="http://loophole.studio">Home</a></li>
                <li><a href="">Network Engineering</a></li>
                <li><a href="https://www.youtube.com/channel/UCZMPBxz5CQ46l0fO0K1duRQ?view_as=subscriber" target="_blank">My Youtube Channel</a></li>
                <li><a href="">Post</a></li>
            </ul>
        </div>
        <div class="MainContent">
            <div class="TableOfContent_v2">
                <p>Layers</p>
                <div class="layers">
                    <a href="http://loophole.studio/network/osimodel_v2.html"><div class="eachlayer" >Physical layer</div></a>
                    <a href=""><div class="eachlayer" style="background-color: orange; color: white;">Data Link layer</div></a>
                    <a href=""><div class="eachlayer">Network layer</div></a>
                    <a href=""><div class="eachlayer">Transport layer</div></a>
                    <a href=""><div class="eachlayer">Session layer</div></a>
                    <a href=""><div class="eachlayer">Presentation layer</div></a>
                    <a href=""><div class="eachlayer">Application layer</div></a>
                </div>
                <p>Table of Contents</p>
                <ul id="intro">
                    <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="DataScroll()">Data Link layer</a></li>
                    <ol>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="HubScroll()">hub</a></li>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="SwitchScroll()">switch</a></li>
                        <ul>
                            <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="MacScroll()">MAC address</a></li>
                        </ul>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="BridgeScroll()">Bridge</a></li>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="RouterScroll()">Router</a></li>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="EthernetScroll()">Ethernet</a></li>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="BroadcastScroll()">Broadcast Domain</a></li>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="FramingScroll()">Framing</a></li>
                        <ul>
                            <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="FixedScroll()">Fixed length (bits) framing</a></li>
                            <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="LengthScroll()">Length-based framing</a></li>
                            <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="FlagsScroll()">Flags (Sentinels)</a></li>
                            <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="StuffingScroll()">Stuffing</a></li>
                            <ul>
                                <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="ConsistentScroll()">Consistent-Overhead Byte Stuffing</a></li>
                            </ul>
                        </ul>
                    </ol>
                    <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="reference()">reference</a></li>

                </ul>
            </div>
            <div class="WordArea" onscroll="scrollFunction()">
                <div class="FixedElement"></div>
                <h1 id="DataScroll">Data Link layer:</h1>
                <div>
                    <div class="intro_box">
                        When we think of data link layer we can consider it as the stuffing in a sandwich. And the two slices of bread that hold it are <strong>physical layer and network layer.</strong> Data link layer must make sure data from physical layer is correctly transmitted to network layer and vice versa. And we will cover how it performs this task in the following article. <br>Before getting started let's first look at some devices you need to know.
                    </div>
                    <div class="intro_pic">
                        <img src="http://loophole.studio/images/osi_model/datalink/sandwich.png" id="sandwich" alt="">
                    </div>
                </div>
                <ul>
                    <div>
                        <div class="intro_box" id="HubScroll">
                            <b>Hub:</b><br>
                            Hub is a stupid guy who can’t remember others’ names just like me xd. So, whenever he’s in charge of sending data to someone, he always sends it to everyone. So, if today computer A meant to send a package to computer B and computer A accidentally sent the package to a hub instead of a <strong>switch</strong> (we will talk about it later), not only computer B will receive the package, but every computer that is connected to the hub will receive the same package. This is because hubs will copy the package many times making sure that every computer on its ports will receive a package. Moreover, It is usually used in <strong>LAN (Local Area Network).</strong>
                        </div>
                        <div class="intro_pic">
                            <img src="http://loophole.studio/images/osi_model/datalink/hub.png" id="sandwich" alt="">
                        </div>
                    </div>
                    
                </ul>
                
                <ul>
                    <div>
                        <div class="intro_box" id="SwitchScroll">
                            <b>Switch:</b><br>
                            If hubs are the stupid guys then switches are the smart ones. Switches would memorize the <strong>MAC address</strong> of each device that is connected to it. In other words, if one day he has to send a package to computer A then only computer A will receive the package. Switches can be separated into two types: <strong>layer 2 switches and layer 3 switches.</strong> Basically, layer 3 switches can perform every layer 2 switches’ functions, and we will talk about what it can do additionally next time when we enter <strong>layer 3 – network layer.</strong>
                        </div>
                        <div class="intro_pic">
                            <img src="http://loophole.studio/images/osi_model/datalink/switch.png" id="sandwich" alt="">
                        </div>
                    </div>
                    
                </ul>
                                
                <ul>
                    <ul>
                        <br>
                        <div class="question">
                            Let's pause for a bit because I know someone would have this question. “What is mac address?”
                        </div>
                        <br><br>
                        <b id="MacScroll">MAC address</b>
                        <br>
                        MAC stands for <strong>Media Access Control.</strong> It is a hardware address meaning that it is <strong>unique and unchangeable</strong>. It is also a physical address or burn-in address, but they kind of mean the same thing. Usually mac address is tied with your Network Interface Card (NIC, a computer circuit card that makes your computer able to connect to the internet). 
                        MAC stands for <strong>Media Access Control.</strong> It is a hardware address meaning that it is <strong>unique and unchangeable</strong>. It is also a <strong>physical address or burn-in address,</strong> but they kind of mean the same thing. Usually mac address is tied with your <strong>Network Interface Card</strong> (NIC, a computer circuit card that makes your computer able to connect to the internet). 
                        Here’s an example of a MAC address of an Ethernet NIC: 00:0a:86:9d:78:17
                        As you can see, it is generated by <strong>8 octets</strong> and each octet stand for <strong>8 bits.</strong> Moreover, they can be separated by <strong>colons or dashes.</strong>
                        <br>
                        <div class="piccontainer">
                            <img src="http://loophole.studio/images/osi_model/datalink/oui.png" id="oui" alt="">
                        </div>
                        <br>
                        For the first <strong>3 octets</strong> are known as <strong>Organizationally unique identifier (OUI),</strong> which is assign to a manufacturer by the <strong>Institute of Electrical and Electronics Engineers (IEEE) Registration Authority.</strong> Which means by looking at it you can probably figure out who made your network adapter or NICs.
                        <br><br>
                        <div class="homework">
                            <b>TODAY'S HOMEWORK:</b>
                            <br>
                            Go to this <a href="https://hwaddress.com/?q=A4-83-E7%09" target="_blank">website</a> and go check out which company made your NIC card (type in the first three octects).
                        </div>
                    </ul>
                </ul>
                
                <ul>
                    <div>
                        <div class="intro_box">
                            <b id="BridgeScroll">Bridge:</b>
                            <br>
                            Bridge is a device that is designed to separate the network into segments in order to reduce collision. Each segment has its own <strong>collision domain.</strong> And because each collision has its own bandwidth, which means bridge can also improve the network performance. Bridge is a layer two device that can forward or filter data. However, it is no longer a common thing we use. Instead, we prefer <strong>switches.</strong>
                        </div>
                        <div class="intro_pic">
                            <img src="http://loophole.studio/images/osi_model/datalink/bridge.png" id="sandwich" alt="">
                        </div>
                    </div>
                </ul>
                
                <ul>
                    <b id="RouterScroll">Router:</b>
                    <br>
                    Router is a <strong>layer 3</strong> device so I will introduce it next time.
                </ul>
                Let’s get back to our topic – data link layer. Data link layer functions on connections that are <strong>point to point or broadcast.</strong> And you might start wondering, “what is broadcasting?” A <strong>broadcast message</strong> is a message that is sent from a single system to all the other systems in the same <strong>broadcast domain.</strong>
                <br><br>
                <div class="question">Then you might ask “so… what is a broadcast domain?”</div>
                <br>
                Before answering that question, let’s first make sure you understand what ethernet is.
                <br><br>
                <ul>
                    <b id="EthernetScroll">Ethernet: </b>
                    <br>
                    Ethernet is a technology used in wired <strong>LAN or WAN (Wide Area Network)</strong> environment. It functions to transmit data and makes sure other devices can recognize and process the information.
                    <br><br>
                    Now let’s talk about broad cast domain.
                    <br><br>
                </ul>

                <ul>
                    <b id="BroadcastScroll">Broadcast Domain:</b>
                    <br>
                    It is a specific network segment that all devices can communicate with each other through <strong>ethernet broadcast</strong>. Although, I haven’t explained what router is. It is important for you to know that router will divide a LAN in to multiple <strong>broadcast domain</strong> and each <strong>port</strong> on the router is in different domains.
                    <br><br>
                    <div class="piccontainer">
                        <img src="http://loophole.studio/images/osi_model/datalink/broadcast_domain.png" alt="" id="domain">
                    </div>
                    <br>
                    In the picture above you can see that all ports on devices such as <strong>bridges, hubs, and switches</strong> are on the same domain. 
                </ul>
                <div class="question">“Does data link layer have sublayers?”</div>
                <ul>
                    Yes, it does. Data link layer contain two sublayers: Logical Link Control (LLC) and Media Access Control (MAC)
                    <br>
                    <br>
                    <ul>
                        <strong>Logical Link Control (LLC):</strong> this layer deals with protocols, flow-control, and error control.
                        <br>
                        <strong>Media Access Control (MAC):</strong> this layer deals with the control of media.
                    </ul>
                </ul>
                <div class="question">“So, what are some data link’s function?”</div>
                <ul>
                    <b id="FramingScroll">Framing:</b>
                    <br>
                    Framing is performed by the <strong>LLC sublayer.</strong> Like how I described data link layer, it is the stuffing in a sandwich. It will receive the packets from Network layer and make them into frames. But why? Why don’t we use packets to transmit data? Is it necessary to use a new unit? Well, the answer is yes. Framing makes sure that data sent from the senders makes sense to the receivers, and it also makes it easier to detect corruption as data is broken down into pieces. Usually, the structure of frames contains a <strong>header</strong> but not always a <strong>trailer</strong>, and the header is used to store information such as <strong>error-checking codes and addressing information.</strong>
                    <br>
                    <div class="piccontainer">
                            <img src="http://loophole.studio/images/osi_model/datalink/frame.png" alt="" id="frame">
                        </div>
                    <br>
                    The first thing to do: identify frames.
                    <br>
                    Receivers have to know where frames start and end so that they can identify the transmitted data.
                    <br>
                    Types of framing: <strong>Fixed length (bits) framing, fixed duration (second) framing, and length-based framing.</strong>
                    <br><br>
                    <ul>
                        <b id="FixedScroll">Fixed length (bits) framing:</b>
                        <br>
                        In this type of framing, the receivers are easier to understand and process the frames. However, it is inefficient when you are dealing with small payloads. Moreover, it will also be inconvenient to handle big payloads because you have to break them down making them fragmented.
                        <br><br>
                        <div class="question">
                            So, you might ask, “What is a better way of framing?”
                        </div>
                        <br>
                    </ul>
                    <ul>
                        <b id="LengthScroll">Length-based framing:</b>
                        <br>
                        Well, we have length-based framing. Instead of a fixed length, every frame declares how long it is. But it might still not be an ideal way because you have to make sure the receivers read the length field correctly, and it also means the receivers have to identify the beginning.
                        <div class="piccontainer">
                            <img src="http://loophole.studio/images/osi_model/datalink/length_based.png" alt="" id="frame">
                        </div>
                    <br>
                    </ul>
                    <br>
                    So, it brings us to another alternative: <strong>Flags or Sentinels.</strong>
                    <br><br>
                    <ul>
                        <b id="FlagsScroll">Flags (Sentinels)</b>
                        <br>
                        Think about it. What if we use something recognizable to identify the start and the end of a frame? 
                        One type of indicator is a special bit or byte pattern in the header or trailer. 
                        However, it does have disadvantages. For example, special bit or byte patterns can sometimes overlap with the bits in the data, which makes the frame start later or end earlier. But there is a solution to this problem.
                        <br><br>
                    </ul>
                    <ul>
                        <b id="StuffingScroll">Stuffing:</b>
                        <br>
                        This method inserts bits or bytes into data so that flags or sentinels won’t appear in the data stream. Usually, the bit pattern of sentinels would be <strong>01111110 (0x7E)</strong>, and it is designed for <strong>High-Level Data Link Control (HDLC) and Synchronous Data Link Control (SDLC).</strong>
                        <br><br>
                        <div class="question">So, where do we insert the bits?</div>
                        <br>
                        Whenever the senders see <strong>5 ones</strong> beside each other, it would add a one beside them since there are 6 ones in our sentinel (01111110). When the receivers are destuffing, it would remove 1 zero when they read 5 ones. If there is no zero to remove means two things: there is either a flag or an error. Also, <strong>01111111 (0x7F)</strong> is unacceptable in a data stream.
                        <div class="piccontainer">
                                <img src="http://loophole.studio/images/osi_model/datalink/bitstuff.png" alt="" id="bitstuff">
                        </div>
                        <br>
                        Let’s now do some math. If we use 01110 as a flag meaning that we have to insert 1 zero every 2 ones. In other words, if we use <strong>01*n0</strong> we have to insert 1 zero every <strong>n-1</strong> ones. When the payload is long, we should use a long flag, and when the payload is short, we should use a short flag.
                        <br><br>
                        Let’s now put it in the scale of <strong>bytes.</strong> (just in case you forget. <strong>1 byte = 8 bits</strong>)
                        It is generally similar to bit stuffing, but there are two different flags: <strong>STX and ETX.</strong> One at the very beginning, and one at the very end. To prevent these two flags to appear in the payload, there is another character known as <strong>DLE (data-link escape)</strong> to solve this problem. 
                        <div class="piccontainer">
                                <img src="http://loophole.studio/images/osi_model/datalink/bytestuffing.png" alt="" id="bitstuff">
                        </div>
                        However, things can get really bad when DLE accidentally appears in the payload. There is another way of byte stuffing known as the <strong>Consistent-Overhead Byte Stuffing.</strong>
                        <br><br>
                        <ul>
                            <b id="ConsistentScroll">Consistent-Overhead Byte Stuffing: </b>
                            <br>
                            It uses <strong>0x00</strong> as a flag. You might wonder, “isn’t it making even more conflicts?” Well, it changes every 00 in the data stream. But how? It might be easier to demonstrate with a picture, so let’s look at the picture bellow.
                            <div class="piccontainer">
                                <img src="http://loophole.studio/images/osi_model/datalink/overhand.png" alt="" id="bitstuff">
                            </div>
                            As you can see, each 00 is changed into the distance to the next 00. The max distance is <strong>254.</strong> If there is no 00 in the distance of 254 it will be represented by <strong>255 (0xFF).</strong>
                            <br><br>
                            Although the methods above might sound perfect to you, they still contain problems such as the existence of missed flags and spurious flags. So, some genius came up with the idea of using time instead.
                        </ul>
                        <br>
                        <b>Clock-Based Framing:</b>
                        <br>
                        By using an external clock, it does not need any bit to show the length of the data stream but has to rely on precise <strong>clock synchronization</strong> between the receivers and the senders. Another framing that relies on an external clock is <strong>SONET (Synchronous Optical NETwork),</strong> but I decide not to introduce it for now. If you are interested, I strongly recommend you do some research.
                        <br>
                        <br>
                    </ul>
                    <b>Addressing:</b>
                    <br>
                    Data-link layer utilizes hardware addressing mechanism to give different devices unique <strong>hardware addresses.</strong> This might sound familiar because we have talked about it. And if you pay enough attention you will notice that I'm now talking about <strong>MAC addresses (hardware address).</strong> But have you wondered how does one computer discover another computer’s <strong>layer 2 address?</strong> If you do, the answer to this question is quite simple, which is a method known as <strong>ARP (Address Resolution Protocol).</strong>
                    <br>
                    <br>
                    <ul>
                        <b>Address Resolution Protocol (ARP):</b>
                        <br>
                        The term “Address Resolution” means the process of finding an address of a computer in a network. The basic concept of ARP is to find <strong>MAC addresses</strong> through IP addresses (specifically <strong>IPv4,</strong> we will talk about IP addresses when we reach <strong>network layer</strong>). So, what exactly a computer does is that it will send out a <strong>broadcast</strong> asking which device owns the IP address, for example, 10.0.0.1 and what is its MAC address. The computer will also provide its IP address and MAC address so that the device they are looking for can reply. When the target device heard someone calling its IP address they will respond and provide its MAC address, for example, 00:0a:86:9d:78:17. I know it may sound a bit abstract so I will perform the whole process of ARP in my video. <br><br>
                        There are two types of ARP message:
                        <ol>
                            <li><strong>ARP-Request</strong> (send with <strong>Broadcast,</strong> source IP address of the requester)</li>
                            <li><strong>ARP-Reply</strong> (send with <strong>Unicast</strong> to requester, the target)</li>
                        </ol>
                        <br>
                        <div class="question">
                            So are you saying that it will run ARP every time whenever my computer tries to find a device's MAC address?”
                        </div>
                        <br>
                        No, actually. It will be a waste of time to run ARP when your computer has already communicated to the target device. In fact, there is a <strong>cache</strong> storing the MAC address a computer knows. If you want to check that out in your computer open your terminal and simply type:
                        <br>
                        <div class="command">
                            arp -a
                        </div>
                        <strong>ARP cache</strong> has a specific size meaning that it will be a waste of space if your computer stores a lot of address that no longer use in it. Therefore, ARP cache is periodically <strong>flushed</strong> meaning that it will go through all the addresses and delete those that seldom use.

                        <br>
                    </ul>
                    <b>Frame Synchronization</b>
                </ul>
                
                <div class="reference">
                    <b id="refer">Reference:</b>
                    <p id="1"><a href="https://www.studytonight.com/computer-networks/osi-model-physical-layer" target="_blank">[1] Ahlawat, A. (n.d.). Physical Layer - OSI Reference Model. Retrieved July 12, 2020</a></p>

                    <p id="2"><a href="https://www.tutorialspoint.com/data_communication_computer_network/physical_layer_introduction.htm" target="_blank">[2] DCN - Physical Layer Introduction. (n.d.). Retrieved July 12, 2020</a></p>


                    <p id="3"><a href="https://www.guru99.com/analog-vs-digital.html" target="_blank">[3] Analog vs Digital: What's the Difference? (n.d.). Retrieved July 12, 2020</a></p>


                    <p id="4"><a href="https://www.geeksforgeeks.org/frequency-division-and-time-division-multiplexing/" target="_blank">[4] S. (2019, September 09). Frequency Division and Time division multiplexing. Retrieved July 19, 2020</a></p>

                    <p id="5"><a href="https://electronicscoach.com/time-division-multiplexing.html" target="_blank">[5] What is Time Division Multiplexing (TDM)? Theory,block diagram, advanatages, disadvantages and applications of TDM. (2018, October 06). Retrieved July 21, 2020</a></p>
                </div>
            </div>
        </div>
    </body>
</html>