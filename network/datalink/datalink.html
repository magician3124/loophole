<!DOCTYPE html>
<html>
    <head>
        <title>LoopHole</title>
        <link rel="icon" href="http://loophole.studio/images/favicon.ico" type="x-icon" />
        <link rel="stylesheet" type="text/css" href="datalink.css">
        <script src="https://kit.fontawesome.com/b99e675b6e.js"></script>
        <script src="navbar.js"></script>
        <script src="data_table.js"></script>
        <script src="http://loophole.studio/network/totop.js"></script>
        <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body>
    <button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>
        <div class="hero-image">
        
          <div class="hero-text">
            <h1>Osi Model</h1>
            <p>By Wilson</p>
          </div>
        </div>
        <div class="menu" id="navbar">
            <ul>
                <li><a href="http://loophole.studio">Home</a></li>
                <li><a href="">Network Engineering</a></li>
                <li><a href="https://www.youtube.com/channel/UCZMPBxz5CQ46l0fO0K1duRQ?view_as=subscriber" target="_blank">My Youtube Channel</a></li>
                <li><a href="">Post</a></li>
            </ul>
        </div>
        <div class="MainContent">
            <div class="TableOfContent_v2">
                <p>Layers</p>
                <div class="layers">
                    <a href="http://loophole.studio/network/osimodel_v2.html"><div class="eachlayer" >Physical layer</div></a>
                    <a href=""><div class="eachlayer" style="background-color: orange; color: white;">Data Link layer</div></a>
                    <a href=""><div class="eachlayer">Network layer</div></a>
                    <a href=""><div class="eachlayer">Transport layer</div></a>
                    <a href=""><div class="eachlayer">Session layer</div></a>
                    <a href=""><div class="eachlayer">Presentation layer</div></a>
                    <a href=""><div class="eachlayer">Application layer</div></a>
                </div>
                <p>Table of Contents</p>
                <ul id="intro">
                    <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="DataScroll()">Data Link layer</a></li>
                    <ol>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="HubScroll()">hub</a></li>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="SwitchScroll()">switch</a></li>
                        <ul>
                            <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="MacScroll()">MAC address</a></li>
                        </ul>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="BridgeScroll()">Bridge</a></li>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="RouterScroll()">Router</a></li>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="EthernetScroll()">Ethernet</a></li>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="BroadcastScroll()">Broadcast Domain</a></li>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="FramingScroll()">Framing</a></li>
                        <ul>
                            <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="FixedScroll()">Fixed length (bits) framing</a></li>
                            <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="LengthScroll()">Length-based framing</a></li>
                            <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="FlagsScroll()">Flags (Sentinels)</a></li>
                            <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="StuffingScroll()">Stuffing</a></li>
                            <ul>
                                <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="ConsistentScroll()">Consistent-Overhead Byte Stuffing</a></li>
                            </ul>
                            <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="ConsistentScroll()">Clock-Based Framing</a></li>
                        </ul>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="ConsistentScroll()">Addressing</a></li>
                        <ul>
                            <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="ConsistentScroll()">Address Resolution Protocol (ARP)</a></li>
                        </ul>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="ConsistentScroll()">Synchronization</a></li>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="ConsistentScroll()">Error control</a></li>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="ConsistentScroll()">Flow control</a></li>
                        <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="ConsistentScroll()">Multi-Access</a></li>
                    </ol>
                    <li><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false;" onmousedown="reference()">reference</a></li>

                </ul>
            </div>
            <div class="WordArea" onscroll="scrollFunction()">
                <div class="FixedElement"></div>
                <h1 class="title_big" id="DataScroll">Data Link layer:</h1>
                <div>
                    <div class="intro_box">
                        Data link layer is like the stuffing in a sandwich. And the two slices of bread that hold it are <strong>physical layer</strong> and <strong>network layer</strong> because Data link layer ensure that data is correctly transmitted between the two layers. Let’s start from introducing some devices that belongs to the data link layer.
                    </div>
                    <div class="intro_pic">
                        <img src="http://loophole.studio/images/osi_model/datalink/sandwich.png" id="sandwich" alt="">
                    </div>
                </div>
                <h1>Devices </h1>
                <div>
                    <div class="intro_box" id="HubScroll">
                        <b>Hub: </b><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false" onmousedown="cite()">[1]</a><br>
                        Hub is kind of the stupid guy. Because whenever he is in charge of sending data, he never tries to remember who he should be sending to. Instead he will copy the data many times and send it to everyone that he knows. So, if today computer A meant to send a package to computer B and computer A accidentally sent the package to a hub instead of a <strong>switch</strong> (we will talk about it later), not only computer B will receive the package, but every computer that is connected to the hub will receive the same package. Moreover, hubs are usually used in <strong>LAN (Local Area Network).</strong>
                    </div>
                    <div class="intro_pic">
                        <img src="http://loophole.studio/images/osi_model/datalink/hub.png" id="sandwich" alt="">
                    </div>
                </div>   
                <br>
                <div>
                    <div class="intro_box" id="SwitchScroll">
                        <b>Switch: </b><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false" onmousedown="cite()">[2]</a><br>
                        In contrast, switch seems to be way smarter than him. He will ensure that only the devices the sender ask to send to will receive the data by memorizing the <strong>MAC address</strong> of each device. Switches can be separated into two types: <strong>layer 2 switches and layer 3 switches.</strong> Basically, layer 3 switches can perform every layer 2 switches’ functions, and we will talk about what it can do additionally next time when we enter <strong>layer 3 – network layer.</strong>
                    </div>
                    <div class="intro_pic">
                        <img src="http://loophole.studio/images/osi_model/datalink/switch.png" id="sandwich" alt="">
                    </div>
                </div>
                <ul>
                    <ul>
                        <div class="question" id="MacScroll">
                            Let's pause for a sec, “What is a MAC address?” <a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false" onmousedown="cite()">[3]</a>
                        </div>
                        <br>
                        MAC stands for <strong>Media Access Control.</strong> We categorize it as a <strong>hardware address, physical address or burn-in address</strong> meaning that it is unique and unchangeable. Usually mac address is tied with your Network Interface Card (NIC, a computer circuit card that makes your computer able to connect to the internet). 
                        Here’s an example of a MAC address of an Ethernet NIC: 00:0a:86:9d:78:17
                        As you can see, it is generated by <strong>8 octets</strong> and each octet stand for <strong>8 bits.</strong> Moreover, they can be separated by either <strong>colons or dashes.</strong>
                        <br>
                        <div class="piccontainer">
                            <img src="http://loophole.studio/images/osi_model/datalink/oui.png" id="oui" alt="">
                        </div>
                        <br>
                        The first <strong>3 octets</strong> are known as <strong>Organizationally unique identifier (OUI),</strong> which is assign to a manufacturer by the <strong>Institute of Electrical and Electronics Engineers (IEEE) Registration Authority.</strong> Which means by looking at it you can figure out which company made your network adapter or NICs.
                        <br><br>
                        <div class="homework">
                            <b>TODAY'S HOMEWORK:</b>
                            <br>
                            Go to this <a href="https://hwaddress.com/?q=" target="_blank">website</a> and go check out which company made your NIC card (type in the first three octects).
                        </div>
                    </ul>
                </ul>
                
                <div>
                    <div class="intro_box">
                        <b id="BridgeScroll">Bridge: </b><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false" onmousedown="cite()">[4]</a>
                        <br>
                        Bridge is a device that is designed to separate the network into segments in order to reduce collision. Each segment has its own <strong>collision domain.</strong> And because each collision has its own bandwidth, utilizing bridges can also improve the network performance. Bridge is a layer two device that can forward or filter data. However, it is no longer a common thing we use. Instead, we prefer to use <strong>switches.</strong>
                    </div>
                    <div class="intro_pic">
                        <img src="http://loophole.studio/images/osi_model/datalink/bridge.png" id="sandwich" alt="">
                    </div>
                </div>
                <br>
                <b id="RouterScroll">Router:</b>
                <br>
                Router is a <strong>layer 3</strong> device so I will introduce it next time.
                
                <h1>Functions</h1>
                Data link layer functions on connections that are <strong>point to point or broadcast.</strong>
                <ul>
                    <ul>
                        <div class="question">“What is Broadcast?”<a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false" onmousedown="cite()">[5]</a></div>
                        <br>
                        A <strong>broadcast message</strong> is a message that is sent from a single system to all the other systems in the same <strong>broadcast domain.</strong> Before explaining what a broadcast domain is, it is important for you to understand what ethernet is.
                        <br><br>
                        <b id="EthernetScroll">Ethernet: </b><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false" onmousedown="cite()">[6]</a>
                        <br>
                        Ethernet is a technology used in wired <strong>LAN or WAN (Wide Area Network)</strong> environment. It functions to transmit data and makes sure other devices can recognize and process the information.
                        <br><br>
                        <b id="BroadcastScroll">Broadcast Domain: </b><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false" onmousedown="cite()">[7]</a>
                        <br>
                        It is a specific network segment that all devices can communicate with each other through <strong>ethernet broadcast</strong>. Although, I haven’t explained what router is. It is important for you to know that router will divide a LAN into multiple <strong>broadcast domain</strong> and each <strong>port</strong> on the router represent a different domain.
                        <br><br>
                    <div class="piccontainer">
                        <img src="http://loophole.studio/images/osi_model/datalink/broadcast_domain.png" alt="" id="domain">
                    </div>
                    <br>
                    In the picture above you can see that all ports on devices such as <strong>bridges, hubs, and switches</strong> are on the same domain. 

                    </ul>
                </ul>
                <b>Sublayers of Data Link Layer: <a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false" onmousedown="cite()">[1]</a></b>
                <br>
                Data link layer contain two sublayers: <strong>Logical Link Control (LLC)</strong> and <strong>Media Access Control (MAC)</strong>
                <br>
                <ul>
                    <ul>
                        <strong>Logical Link Control (LLC):</strong> deals with protocols, flow-control, and error control.
                        <br>
                        <strong>Media Access Control (MAC):</strong> deals with the control of media.
                    </ul>
                </ul>
                <h1>Lists of Functions</h1>
                    <b id="FramingScroll">Framing: </b><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false" onmousedown="cite()">[8]</a>
                    <br>
                    Framing is performed by the <strong>LLC sublayer.</strong> Like how I described data link layer: it is the stuffing in a sandwich. It will receive the packets from Network layer and make them into frames. But why? Why don’t we use packets to transmit data? Is it necessary to use a new unit? Well, the answer is yes. Framing makes sure that data sent from the senders makes sense to the receivers, and it also makes it easier to detect corruption as data is broken down into pieces. Usually, the structure of frames contains a <strong>header</strong> but not always a <strong>trailer</strong>, and the header is used to store information such as <strong>error-checking codes and addressing information.</strong>
                    <br>
                    <div class="piccontainer">
                            <img src="http://loophole.studio/images/osi_model/datalink/frame.png" alt="" id="frame">
                        </div>
                    <br>
                    The first thing to do as a receiver: identify frames.
                    <br>
                    Receivers have to know where frames start and end so that they can identify the transmitted data.
                    <br>
                    Types of framing: <strong>Fixed length (bits) framing, fixed duration (second) framing, and length-based framing.</strong>
                    <br><br>
                    <ul>
                        <ul>
                            <b id="FixedScroll">Fixed length (bits) framing:</b>
                            <br>
                            In this type of framing, the receivers are easier to understand and process the frames. However, it is inefficient when you are dealing with small payloads. Moreover, it will also be inconvenient to handle big payloads because you have to break them down making them fragmented.
                            <br><br>
                        </ul>
                        <ul>
                            <b id="LengthScroll">Length-based framing:</b>
                            <br>
                            Instead of a fixed length, every frame declares how long it is. But it's still not the most ideal way because you have to make sure the receivers read the length field correctly, and it also means the receivers have to identify the beginning.
                            <div class="piccontainer">
                                <img src="http://loophole.studio/images/osi_model/datalink/length_based.png" alt="" id="frame">
                            </div>
                        <br>
                        </ul>
                        <ul>
                            <b id="FlagsScroll">Flags (Sentinels)</b>
                            <br>
                            The basic concept of flags is to use something recognizable to identify the start and the end of a frame.
                            One type of indicator is a special bit or byte pattern in the header or trailer. 
                            However, it does have disadvantages. For example, special bit or byte patterns can sometimes overlap with the bits in the data, which makes the frame start later or end earlier. But there is a solution to this problem.
                            <br><br>
                        </ul>
                        <ul>
                            <b id="StuffingScroll">Stuffing:</b>
                            <br>
                            This method inserts bits or bytes into data so that flags or sentinels won’t appear in the data stream. Usually, the bit pattern of flags (<strong>bit stuffing</strong>) would be <strong>01111110 (0x7E)</strong>.
                            <br><br>
                            Whenever the senders see <strong>5 ones</strong> beside each other, it would add 1 zero beside them since there are 6 ones in our sentinel (01111110). When the receivers are destuffing, it would remove 1 zero when they read 5 ones. If there is no zero to remove means two things: there is either a flag or an error. In other words, <strong>01111111 (0x7F)</strong> would be unacceptable in a data stream.
                            <div class="piccontainer">
                                    <img src="http://loophole.studio/images/osi_model/datalink/bitstuff.png" alt="" id="bitstuff">
                            </div>
                            <br>
                            Let’s now do some math. If we use 01110 as a flag meaning that we have to insert 1 zero every 2 ones. In other words, if we use <strong>01*n0</strong> we have to insert 1 zero every <strong>n-1</strong> ones. When the payload is long, we should use a long flag, and when the payload is short, we should use a short flag.
                            <br><br>
                            Let’s now put it in the scale of <strong>bytes.</strong> (just in case you forget. <strong>1 byte = 8 bits</strong>)
                            It is generally similar to bit stuffing, but there are two different flags: <strong>STX and ETX.</strong> One at the very beginning, and one at the very end. To prevent these two flags to appear in the payload, there is another character known as <strong>DLE (data-link escape)</strong> to avoid this problem. 
                            <div class="piccontainer">
                                    <img src="http://loophole.studio/images/osi_model/datalink/bytestuffing.png" alt="" id="bitstuff">
                            </div>
                            However, things can get really bad when DLE accidentally appears in the payload. We also have another type of byte stuffing known as the <strong>Consistent-Overhead Byte Stuffing.</strong>
                            <br><br>
                            <b id="ConsistentScroll">Consistent-Overhead Byte Stuffing: </b>
                            <br>
                            It uses <strong>0x00</strong> as a flag. It might be easier to demonstrate with a picture, so let’s look at the picture bellow.
                            <div class="piccontainer">
                                <img src="http://loophole.studio/images/osi_model/datalink/overhand.png" alt="" id="bitstuff">
                            </div>
                            As you can see, each 00 is changed into the distance to the next 00. The max distance is <strong>254.</strong> If there is no 00 in the distance of 254 it will be represented by <strong>255 (0xFF).</strong>
                            <br><br>
                            Although the methods above might sound perfect to you, they still contain problems such as the existence of missed flags and spurious flags. So, some genius came up with the idea of using time instead.
                            <br><br>
                            <b>Clock-Based Framing:</b>
                            <br>
                            By using an external clock, it does not need any bit to show the length of the data stream but has to rely on precise <strong>clock synchronization</strong> between the receivers and the senders. Another framing that relies on an external clock is <strong>SONET (Synchronous Optical NETwork),</strong> but I decide not to introduce it for now. If you are interested, I strongly recommend you do some research.
                            <br>
                            <br>
                        </ul>
                    </ul>
                    <b>Addressing:</b>
                    <br>
                    Data-link layer utilizes hardware addressing mechanism to give different devices unique <strong>hardware addresses.</strong> This might sound familiar because we have talked about it. And if you pay enough attention you will notice that I'm now talking about <strong>MAC addresses (hardware address).</strong> But how does one computer discover another computer’s <strong>layer 2 address?</strong> The answer to this question is quite simple: it is a method known as <strong>ARP (Address Resolution Protocol).</strong>
                    <br>
                    <br>
                    <ul>
                        <ul>
                            <b>Address Resolution Protocol (ARP): </b><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false" onmousedown="cite()">[9]</a>
                            <br>
                            The term “Address Resolution” means the process of finding an address of a computer in a network.<a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false" onmousedown="cite()">[10]</a> The basic concept of ARP is to find <strong>MAC addresses</strong> through IP addresses (specifically <strong>IPv4,</strong> we will talk about IP addresses when we reach <strong>network layer</strong>). So, what exactly a computer does is that it will send out a <strong>broadcast</strong> asking which device owns the IP address, for example, 10.0.0.1 and what is its MAC address. The computer will also provide its IP address and MAC address so that the device they are looking for can reply. When the target device heard someone calling its IP address they will respond and provide its MAC address, for example, 00:0a:86:9d:78:17. I know it may sound a bit abstract so I will perform the whole process of ARP in my video. <br><br>
                            <b>Two types of ARP message:</b>
                            <ul>
                                <ol>
                                    <li><strong>ARP-Request</strong> (send with <strong>Broadcast,</strong> source IP address of the requester)</li>
                                    <li><strong>ARP-Reply</strong> (send with <strong>Unicast</strong> to requester, the target)</li>
                                </ol>
                            </ul>
                            <br>
                            <div class="question">
                                So are you saying that it will run ARP every time whenever my computer tries to find a device's MAC address?”
                            </div>
                            <br>
                            No, actually. It will be a waste of time to run ARP when your computer has already communicated to the target device. In fact, there is a <strong>cache</strong> storing the MAC address a computer knows. If you want to check that out in your computer open your terminal and simply type:
                            <br>
                            <div class="command">
                                arp -a
                            </div>
                            <div class="piccontainer">
                                <img src="http://loophole.studio/images/osi_model/datalink/arp.png" alt="" id="arp" alt="">
                            </div>
                            <br>
                            <strong>ARP cache</strong> has a specific size meaning that it will be a waste of space if your computer stores address that are no longer used. Therefore, ARP cache is periodically <strong>flushed</strong> meaning that it will go through all the addresses and delete those that are seldom used.

                            <br>
                        </ul>
                    </ul>
                    <br>
                    <b>Frame Synchronization </b><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false" onmousedown="cite()">[11]</a>
                    <br>
                    Frame Synchronization is a task performed by MAC sublayer. It functions to keep the receiver and sender at the same pace. This is also known as <strong>Flow control.</strong> Here are two types of flow control mechanisms: <strong>Stop and Wait and Sliding Window.</strong>
                    <br><br>
                    <ul>
                        <ul>
                            <b>Stop and Wait: </b><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false" onmousedown="cite()">[12]</a><br>
                            The basic concept of <Strong> Stop and Wait</Strong> is that when the receiver receives the data packets from the sender, it will first process the packets and then send an <strong>acknowledgment</strong> back to the sender to tell him that he is ready to receive the next data packet.
                            <br><br>
                            <b>pros:</b>
                            <ul>
                                <li>it is simple to implement</li>
                            </ul>
                            <br>
                            <b>cons:</b>
                            <ul>
                                <li>it slows down the transmission process</li>
                                <li>it is inefficient because part of the bandwidth is distributed to the acknowledgment the receiver sent</li>
                                <li>if data packets are lost during the transmission process, both the receiver and the sender will start waiting for an infinite time.</li>
                            </ul>
                            <div class="piccontainer">
                                <img src="http://loophole.studio/images/osi_model/datalink/stopwait.png" alt="" id="pic_400" alt="">
                            </div>

                            <br>
                            <b>Sliding Window: </b><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false" onmousedown="cite()">[14]</a>
                            <br>
                            Instead of sending acknowledgment after every single frame, the receivers and senders agree on the number of data frames after which the acknowledgment should be sent. By doing so, it wastes fewer resources compare to Stop and Wait flow control mechanism.
                        </ul>
                    </ul>
                    <br><br>
                    <b>Error control: </b><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false" onmousedown="cite()">[1]</a>
                    <br>
                    During transmission of data, noise, cross-talk, and many other factors might cause data to be incorrectly sent to the receivers. To solve this problem, there are multiple methods to ensure the transmission is accurate enough. Let's first look at a few types of errors before getting into those methods.
                    <ul>
                        <ol><strong>Single bits error:</strong> only one bit is opposite to the original one.</ol>
                        <ol><strong>Multiple bits error:</strong> more than one bit is opposite to the original one.</ol>
                        <ol><strong>Burst error:</strong> a series of bits are corrupted</ol>
                    </ul>
                    <br>
                    <b>How to detect errors? </b><a href="http://loophole.studio/subwebsite/network/osimodel.html" onclick="return false" onmousedown="cite()">[13]</a>
                    <br>
                    <b>Parity Check:</b>
                    <ul>
                        <ol><strong>Even parity:</strong> If the original data is 100101, which means there is an odd amount of "1" (“1” * 3) a “1” is added to the right side of the data, making it 1001011. The reason of doing so is to ensure there is an even amount of “1” in the data. If there is already an even amount of “1” in the data, then a “0” is added at the end of the data.</ol>
                        <ol><strong>Odd parity:</strong> if the original data is 0101101, which means there is an even amount of 1 (“1” * 4) a “1” is added to the right side of the data, making it 01011011. The reason of doing so is to ensure there is an odd amount of “1” in the data. If there is an already odd amount of “1” in the data, then a “0” is added at the end of the data.</ol>
                        <br>
                        <ul>
                            *I know this sounds super confusing a graph might help you out.
                        </ul>
                    </ul>
                    <div class="piccontainer">
                            <img src="http://loophole.studio/images/osi_model/datalink/parity.png" alt="" id="bitstuff" alt="">
                    </div>
                    Before the transmission is even started, the receiver and the sender will first agree on the same type of parity, either even or odd. And when the data is sent, the receiver can simply determine whether error exists by counting the number of “1.” If they are using even parity and the number of “1” is odd, then clearly that part of the data is corrupted, and vice versa. However, the fatal flaw of this method is that if multiple bits error, it is hard to determine whether the data is corrupted or not.
                    <br><br>
                    <b>Cyclic Redundancy Check (CRC)</b>
                    <br>
                    Before the data is sent, the original data bits are divided with the divisor. Then, the remainder of the division is added to the end of the data. So, the receiver can simply divide the new data with the same divisor. If the remainder is zero, meaning that no errors occur.
                    <div class="piccontainer">
                            <img src="http://loophole.studio/images/osi_model/datalink/crc.png" alt="" id="arp" alt="">
                    </div><b>
                    How to correct errors? 
                    </b>
                    <br><br>
                    There are two types of error corrections: Backward Error Correction and Forward Error Correction
                    <ul>
                        <strong>Backward Error Correction (BEC):</strong> When an error is detected, the receiver will send a message back to the sender to ask him to retransmit the data unit.
                    </ul>
                    <ul>
                        <strong>Forward Error Correction (FEC):</strong> Instead of requesting the data, it executes error-correcting code to correct the errors. To do so, it has to know where the corrupted data existed. But how? In the simple form of FEC, each data bits are sent twice, and the receiver will check both instances if they match the protocol being used. When conformity exists in both or either one of the instances, the data is accepted. In other words, if conformity occurs in neither instance, the data will be substituted with a blank space. 
                    </ul>
                    Although there are two ways to fix error, not both of them are application in all situations. For example, BEC can only be use when the transmission cost is cheap, such as fiber optics. However, in wireless transmission, it is too expensive to use Backward Error Correction; therefore, we use FEC instead.
                    <br><br>
                
                <div class="reference">
                    <b id="refer">Reference:</b>
                    <p id="1"><a href="https://www.tutorialspoint.com/data_communication_computer_network/data_link_layer_introduction.htm" target="_blank">[1] DCN - Data-link Layer Introduction. (n.d.). Retrieved November 03, 2020</a></p>

                    <p id="2"><a href="https://community.fs.com/blog/do-you-know-the-differences-between-hubs-switches-and-routers.html" target="_blank">[2] “What's the Difference: Hub vs Switch vs Router.” Blog, 3 Nov. 2020</a></p>
                    
                    <p id="3"><a href="https://whatismyipaddress.com/mac-address" target="_blank">[3] What is a MAC Address? (n.d.). Retrieved November 03, 2020</a></p>


                    <p id="4"><a href="https://geek-university.com/ccna/what-is-a-network-bridge/" target="_blank">[4] Geek University. “What Is a Network Bridge?: CCNA.” Geek University</a></p>


                    <p id="5"><a href="https://www.tutorialspoint.com/data_communication_computer_network/data_link_layer_introduction.htm" target="_blank">[5] “DCN - Data-Link Layer Introduction.” Tutorialspoint</a></p>

                    <p id="6"><a href="https://searchnetworking.techtarget.com/definition/Ethernet" target="_blank">[6] Rouse, Margaret. “What Is Ethernet?” SearchNetworking, TechTarget, 9 Mar. 2020</a></p>
                    
                    <p id="7"><a href="https://geek-university.com/ccna/broadcast-domain-explained/" target="_blank">[7] Geek University. “Broadcast Domain Explained: CCNA.” Geek University</a></p>
                    
                    <p id="8"><a href="https://cseweb.ucsd.edu/classes/fa13/cse123-a/lectures/123-fa13-l4.pdf" target="_blank">[8] https://cseweb.ucsd.edu/classes/fa13/cse123-a/lectures/123-fa13-l4.pdf</a></p>
                    
                    <p id="9"><a href="https://www.youtube.com/watch?v=Cx7foWGm5fo" target="_blank">[9] cbtnuggets. “How Address Resolution Protocol (ARP) Works.” YouTube, YouTube, 2 July 2019, www.youtube.com/watch?v=Cx7foWGm5fo.</a></p>
                    
                    <p id="10"><a href="https://erg.abdn.ac.uk/users/gorry/course/inet-pages/arp.html" target="_blank">[10] https://erg.abdn.ac.uk/users/gorry/course/inet-pages/arp.html</a></p>
                    
                    <p id="11"><a href="https://www.techopedia.com/definition/27360/frame-synchronization" target="_blank">[11] “What Is Frame Synchronization? - Definition from Techopedia.” Techopedia.com</a></p>
                    
                    <p id="12"><a href="https://www.gatevidyalay.com/flow-control-stop-and-wait-protocol/" target="_blank">[12] Singhal, Akshay. Akshay Singhal. 15 Dec. 2019, www.gatevidyalay.com/flow-control-stop-and-wait-protocol/.</a></p>
                    
                    <p id="13"><a href="https://www.tutorialspoint.com/data_communication_computer_network/error_detection_and_correction.htm" target="_blank">[13] “DCN - Error Detection &amp; Correction.” Tutorialspoint, www.tutorialspoint.com/data_communication_computer_network/error_detection_and_correction.htm. </a></p>
                    
                    <p id="14"><a href="https://www.tutorialspoint.com/data_communication_computer_network/error_detection_and_correction.htm" target="_blank">[14] “DCN - Data-Link Control &amp; Protocols.” Tutorialspoint, www.tutorialspoint.com/data_communication_computer_network/data_link_control_and_protocols.htm.</a></p>
                </div>
            </div>
        </div>
    </body>
</html>